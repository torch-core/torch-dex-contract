{-
 * @notice Packs the data for a `withdraw_internal` message into a cell.
 * @param query_id The unique query identifier
 * @param provider The address of the liquidity provider that initiated the withdrawal.
 * @param recipient The address of the recipient to receive the withdrawn assets.
 * @param remove_amount The lp amount to be withdrawn.
 * @param signed_rates A cell containing the signed rate data (if required by the pool).
 * @param asset_out A cell representing the asset that provider will receive, if any.
 * @param withdraw_params A cell containing additional withdrawal parameters, if any.
 * @param next A cell containing the `next` information, if any.
 * @return A cell representing the packed `withdraw_internal` message data.
 * @dev 
 * - The pool lp vault will send withdraw_internal message to pool
 * - If asset out is null, pool will withdraw all assets to the recipient
-}
cell pack_withdraw_internal(
    int query_id,
    slice provider,
    slice recipient,
    int remove_amount,
    cell signed_rates,
    cell asset_out,
    cell withdraw_params,
    cell next
) inline {
    return begin_cell()
        .store_op(op::withdraw_internal)
        .store_query_id(query_id)
        .store_slice(provider)
        .store_slice(recipient)
        .store_coins(remove_amount)
        .store_maybe_ref(signed_rates)
        .store_maybe_ref(asset_out)
        .store_maybe_ref(withdraw_params)
        .store_maybe_ref(next)
        .end_cell();
}

{-
 * @notice Unpacks the `withdraw_params` data from a cell.
 * @param withdraw_params A cell containing the packed withdrawal parameters.
 * @return min_amounts A cell representing the minimum withdrawal amount that the provider will accept for each asset.
 * @param extra_payload A cell containing additional data, such as for referral mechanisms.
-}
(cell, cell) unpack_withdraw_params(cell withdraw_params) inline {
    if withdraw_params.cell_null?() {
        return (null(), null());
    }

    slice withdraw_params_slice = withdraw_params.begin_parse();
    cell min_amounts = withdraw_params_slice~load_maybe_ref();
    cell extra_payload = withdraw_params_slice~load_dict();
    withdraw_params_slice.end_parse();

    return (min_amounts, extra_payload);
}

{-
 * @notice Packs the `withdraw_params` data into a cell.
 * @return min_amounts A cell representing the minimum withdrawal amount that the provider will accept for each asset.
 * @param extra_payload A cell containing additional data, such as for referral mechanisms.
 * @return A cell representing the packed `withdraw_params` data.
-}
cell pack_withdraw_params(
    cell min_amounts,
    cell extra_payload
) inline {
    return begin_cell()
        .store_maybe_ref(min_amounts)
        .store_dict(extra_payload)
        .end_cell();
}

{-
 * @notice Packs the data for a `withdraw_between` message into a cell.
 * @param query_id The unique query identifier
 * @param provider The address of the liquidity provider that initiated the withdrawal.
 * @param recipient The address of the recipient to receive the withdrawn assets.
 * @param proof The proof that generated by the meta pool, so that base pool can verify the ctx::sender from proof.
 * @param remove_amount The lp amount to be withdrawn.
 * @param asset_in A cell representing the asset being withdrawn from.
 * @param asset_out A cell representing the asset to be received after the withdrawal, if specified.
 * @param min_amounts A cell containing the minimum amounts that the provider will accept for each asset.
 * @param signed_rates A cell containing the signed rate data (if required by the pool).
 * @return A cell representing the packed `withdraw_between` message data.
 * @dev 
 * - First pool will send withdraw_between message to second pool
 * - If `asset_out` is null, all assets in the second pool will be withdrawn to the recipient.
 * - asset_in will be the second pool's lp asset
-}
cell pack_withdraw_between(
    int query_id,
    slice provider,
    slice recipient,
    int proof,
    int remove_amount,
    cell asset_in,
    cell asset_out,
    cell min_amounts,
    cell signed_rates
) inline {
    return begin_cell()
        .store_op(op::withdraw_between)
        .store_query_id(query_id)
        .store_slice(provider)
        .store_slice(recipient)
        .store_uint(proof, PROOF_SIZE)
        .store_coins(remove_amount)
        .store_ref(asset_in)
        .store_maybe_ref(asset_out)
        .store_maybe_ref(min_amounts)
        .store_maybe_ref(signed_rates)
        .end_cell();
}