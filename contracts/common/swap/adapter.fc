{-
 * @notice Packs the data for a `swap_internal` message into a cell.
 * @param query_id The unique query identifier
 * @param provider The address that initiated the swap.
 * @param asset_in A cell representing the asset being swapped from.
 * @param amount The amount of the input asset to be swapped.
 * @param asset_out A cell representing the asset being swapped to.
 * @param swap_params A cell containing additional swap parameters, if any.
 * @param next A cell containing the `next` information, if any.
 * @return A cell representing the packed `swap_internal` message data.
 * @dev The vault will send swap_internal message to pool
-}
cell pack_swap_internal(
    int query_id, 
    slice provider, 
    cell asset_in, 
    int amount, 
    cell asset_out, 
    cell swap_params, 
    cell next
) inline {
    return begin_cell()
        .store_op(op::swap_internal)    
        .store_query_id(query_id)
        .store_slice(provider)
        .store_ref(asset_in)
        .store_coins(amount)
        .store_ref(asset_out)
        .store_maybe_ref(swap_params)
        .store_maybe_ref(next)
        .end_cell();
}

{-
* @notice Unpacks the `swap_params` cell to extract the swap parameters.
* @param swap_params A cell containing the packed swap parameters.
* @return min_amount The minimum amount of the output asset that provider will accept.
* @return recipient The address of the recipient of the output asset.
* @return signed_rates A cell containing the signed rate data (if required by the pool).
-}
(int, slice, cell, cell, cell, cell) unpack_swap_params(cell swap_params) inline {
    if (swap_params.cell_null?()) {
        return (0, address_none(), null(), null(), null(), null());
    }
    
    slice swap_params_slice = swap_params.begin_parse();
    int min_amount = swap_params_slice~load_coins();
    slice recipient = swap_params_slice~load_msg_addr();
    cell signed_rates = swap_params_slice~load_maybe_ref();
    cell fulfill_payload = swap_params_slice~load_maybe_ref();
    cell reject_payload = swap_params_slice~load_maybe_ref();
    cell extra_payload = swap_params_slice~load_dict();
    swap_params_slice.end_parse();

    return (min_amount, recipient, signed_rates, fulfill_payload, reject_payload, extra_payload);
}

{-
 * @notice Packs the swap parameters into a cell.
 * @param min_amount The minimum amount of the output asset that provider will accept.
 * @param recipient The address of the recipient of the output asset.
 * @param signed_rates A cell containing the signed rate data (if required by the pool).
 * @param fulfill_payload The payload to be sent to the recipient upon a successful swap.
 * @param reject_payload The payload to be sent to the recipient upon a failed swap.
 * @param extra_payload A cell containing additional data, such as for referral mechanisms.
 * @return A cell representing the packed swap parameters.
 * @dev 
 * - The `fulfill_payload` and `reject_payload` should follow the `callback_payload` format, including the amount of TON to send and the payload content.
-}
cell pack_swap_params(
    int min_amount, 
    slice recipient, 
    cell signed_rates, 
    cell fulfill_payload, 
    cell reject_payload, 
    cell extra_payload
) inline {
    return begin_cell()
        .store_coins(min_amount)
        .store_slice(recipient)
        .store_maybe_ref(signed_rates)
        .store_maybe_ref(fulfill_payload)
        .store_maybe_ref(reject_payload)
        .store_dict(extra_payload)
        .end_cell();
}

{-
 * @notice Packs the data for a `swap_between` operation into a cell.
 * @param query_id The unique query identifier
 * @param provider The address that initiated the swap.
 * @param proof The proof that generated by the first pool, so that second pool can verify the ctx::sender from proof.
 * @param asset_in A cell representing the asset being swapped from.
 * @param amount The amount of the input asset to be swapped.
 * @param asset_out A cell representing the asset being swapped to.
 * @param swap_params A cell containing additional swap parameters, if any.
 * @param next A cell containing the `next` information, if any.
 * @return A cell representing the packed `swap_between` operation data.
 * @dev First pool will send swap_between message to second pool
-}
cell pack_swap_between(
    int query_id, 
    slice provider, 
    int proof,
    cell asset_in, 
    int amount, 
    cell asset_out, 
    cell swap_params, 
    cell next
) inline {
    return begin_cell()
        .store_op(op::swap_between)
        .store_query_id(query_id)
        .store_slice(provider)
        .store_uint(proof, PROOF_SIZE)
        .store_ref(asset_in)
        .store_coins(amount)
        .store_ref(asset_out)
        .store_maybe_ref(swap_params)
        .store_maybe_ref(next)
        .end_cell();
}